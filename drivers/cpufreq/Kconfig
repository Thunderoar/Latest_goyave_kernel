menu "CPU Frequency scaling"

config CPU_FREQ
	bool "CPU Frequency scaling"
	help
	  CPU Frequency scaling allows you to change the clock speed of 
	  CPUs on the fly. This is a nice method to save power, because 
	  the lower the CPU clock speed, the less power the CPU consumes.

	  Note that this driver doesn't automatically change the CPU
	  clock speed, you need to either enable a dynamic cpufreq governor
	  (see below) after boot, or use a userspace tool.

	  For details, take a look at <file:Documentation/cpu-freq>.

	  If in doubt, say N.

if CPU_FREQ

config CPU_FREQ_TABLE
	tristate

config CPU_FREQ_GOV_COMMON
	bool

config CPU_FREQ_STAT
	tristate "CPU frequency translation statistics"
	select CPU_FREQ_TABLE
	default y
	help
	  This driver exports CPU frequency statistics information through sysfs
	  file system.

	  To compile this driver as a module, choose M here: the
	  module will be called cpufreq_stats.

	  If in doubt, say N.

config CPU_FREQ_STAT_DETAILS
	bool "CPU frequency translation statistics details"
	depends on CPU_FREQ_STAT
	help
	  This will show detail CPU frequency translation table in sysfs file
	  system.

	  If in doubt, say N.
config CPU_FREQ_LIMIT
	bool "CPU frequency limit API"
	default n
	help
	  This driver supports API to limit CPU frequency.

config CPU_INPUT_BOOST
	bool "CPU Input Boost"
	help
	  Boosts the CPU on touchscreen and touchpad input. Boost frequencies and
	  durations are calculated automatically.

choice
	prompt "Default CPUFreq governor"
	default CPU_FREQ_DEFAULT_GOV_USERSPACE if ARM_SA1100_CPUFREQ || ARM_SA1110_CPUFREQ
	default CPU_FREQ_DEFAULT_GOV_PERFORMANCE
	help
	  This option sets which CPUFreq governor shall be loaded at
	  startup. If in doubt, select 'performance'.

config CPU_FREQ_DEFAULT_GOV_PERFORMANCE
	bool "performance"
	select CPU_FREQ_GOV_PERFORMANCE
	help
	  Use the CPUFreq governor 'performance' as default. This sets
	  the frequency statically to the highest frequency supported by
	  the CPU.

config CPU_FREQ_DEFAULT_GOV_POWERSAVE
	bool "powersave"
	depends on EXPERT
	select CPU_FREQ_GOV_POWERSAVE
	help
	  Use the CPUFreq governor 'powersave' as default. This sets
	  the frequency statically to the lowest frequency supported by
	  the CPU.

config CPU_FREQ_DEFAULT_GOV_USERSPACE
	bool "userspace"
	select CPU_FREQ_GOV_USERSPACE
	help
	  Use the CPUFreq governor 'userspace' as default. This allows
	  you to set the CPU frequency manually or when a userspace 
	  program shall be able to set the CPU dynamically without having
	  to enable the userspace governor manually.

config CPU_FREQ_DEFAULT_GOV_ONDEMAND
	bool "ondemand"
	select CPU_FREQ_GOV_ONDEMAND
	select CPU_FREQ_GOV_PERFORMANCE
	help
	  Use the CPUFreq governor 'ondemand' as default. This allows
	  you to get a full dynamic frequency capable system by simply
	  loading your cpufreq low-level hardware driver.
	  Be aware that not all cpufreq drivers support the ondemand
	  governor. If unsure have a look at the help section of the
	  driver. Fallback governor will be the performance governor.

config CPU_FREQ_DEFAULT_GOV_CONSERVATIVE
	bool "conservative"
	select CPU_FREQ_GOV_CONSERVATIVE
	select CPU_FREQ_GOV_PERFORMANCE
	help
	  Use the CPUFreq governor 'conservative' as default. This allows
	  you to get a full dynamic frequency capable system by simply
	  loading your cpufreq low-level hardware driver.
	  Be aware that not all cpufreq drivers support the conservative
	  governor. If unsure have a look at the help section of the
	  driver. Fallback governor will be the performance governor.

config CPU_FREQ_DEFAULT_GOV_INTERACTIVE
	bool "interactive"
	select CPU_FREQ_GOV_INTERACTIVE
	help
	  Use the CPUFreq governor 'interactive' as default. This allows
	  you to get a full dynamic cpu frequency capable system by simply
	  loading your cpufreq low-level hardware driver, using the
	  'interactive' governor for latency-sensitive workloads.

config CPU_FREQ_DEFAULT_GOV_SPRDEMAND
	bool "sprdemand"
	select CPU_FREQ_GOV_SPRDEMAND
	select CPU_FREQ_GOV_PERFORMANCE
	help
	  Use the CPUFreq governor 'sprdemand' as default. This allows
	  you to get a full dynamic frequency capable system by simply
	  loading your cpufreq low-level hardware driver.
	  Be aware that not all cpufreq drivers support the ondemand
	  governor. If unsure have a look at the help section of the
	  driver. Fallback governor will be the performance governor.

config CPU_FREQ_DEFAULT_GOV_MINMAX
	bool "minmax"
	select CPU_FREQ_GOV_MINMAX
	select CPU_FREQ_GOV_PERFORMANCE
	help
	  Use the CPUFreq governor 'minmax' as default. This minimizes the
	  frequency jumps does by the governor. This is aimed at maximizing
	  both perfomance and battery life.

config CPU_FREQ_DEFAULT_GOV_DARKNESS
	bool "darkness"
	select CPU_FREQ_GOV_DARKNESS
	help

config CPU_FREQ_DEFAULT_GOV_LIONHEART
	bool "lionheart"
	select CPU_FREQ_GOV_LIONHEART
	help

config CPU_FREQ_DEFAULT_GOV_HOTPLUG
	bool "hotplug"
	select CPU_FREQ_GOV_HOTPLUG
	select CPU_FREQ_GOV_PERFORMANCE
	help
	  Use the CPUFreq governor 'hotplug' as default. This allows you
	  to get a full dynamic frequency capable system with CPU
	  hotplug support by simply loading your cpufreq low-level
	  hardware driver.  Be aware that not all cpufreq drivers
	  support the hotplug governor. If unsure have a look at
	  the help section of the driver. Fallback governor will be the
	  performance governor.

config CPU_FREQ_DEFAULT_GOV_HYPER
        bool "HYPER"
        select CPU_FREQ_GOV_HYPER 

config CPU_FREQ_DEFAULT_GOV_ONDEMANDPLUS
	bool "ondemandplus"
	select CPU_FREQ_GOV_ONDEMANDPLUS
	select CPU_FREQ_GOV_PERFORMANCE
	help
	  Use the CPUFreq governor 'ondemandplus' as default. This allows
	  you to get a full dynamic frequency capable system by simply
	  loading your cpufreq low-level hardware driver.
	  Be aware that not all cpufreq drivers support the ondemandplus
	  governor. If unsure have a look at the help section of the
	  driver. Fallback governor will be the performance governor.

config CPU_FREQ_DEFAULT_GOV_ONDEMANDX
	bool "ondemandX"
	select CPU_FREQ_GOV_ONDEMANDX
	select CPU_FREQ_GOV_PERFORMANCE
	help
	  Use the CPUFreq governor 'ondemand' as default. This allows
	  you to get a full dynamic frequency capable system by simply
	  loading your cpufreq low-level hardware driver.
	  Be aware that not all cpufreq drivers support the ondemand
	  governor. If unsure have a look at the help section of the
	  driver. Fallback governor will be the performance governor.
	  OndemandX has built in sleep profile, but not working Sysfs
	  interface

config CPU_FREQ_DEFAULT_GOV_INTELLIACTIVE
	bool "intelliactive"
	select CPU_FREQ_GOV_INTELLIACTIVE
	help
	  Use the CPUFreq governor 'intelliactive' as default. This allows
	  you to get a full dynamic cpu frequency capable system by simply
	  loading your cpufreq low-level hardware driver, using the
	  'interactive' governor for latency-sensitive workloads.

config CPU_FREQ_DEFAULT_GOV_LAGFREE
	bool "lagfree"
	select CPU_FREQ_GOV_LAGFREE
	select CPU_FREQ_GOV_PERFORMANCE
	help
	  Use the CPUFreq governor 'lagfree' as default. This allows
	  you to get a full dynamic frequency capable system by simply
	  loading your cpufreq low-level hardware driver.
	  Be aware that not all cpufreq drivers support the lagfree
	  governor. If unsure have a look at the help section of the
	  driver. Fallback governor will be the performance governor.

config CPU_FREQ_DEFAULT_GOV_NIGHTMARE
	bool "nightmare"
	select CPU_FREQ_GOV_NIGHTMARE
	help

config CPU_FREQ_DEFAULT_GOV_SCARY
	bool "scary"
	select CPU_FREQ_GOV_SCARY
	---help---
	  Use the CPUFreq governor 'scary' as default.

config CPU_FREQ_DEFAULT_GOV_SLEEPY
	bool "sleepy"
	select CPU_FREQ_GOV_SCARY
	---help---
	  Use the CPUFreq governor 'sleepy' as default.

config CPU_FREQ_DEFAULT_GOV_WHEATLEY
	bool "wheatley"
	select CPU_FREQ_GOV_WHEATLEY
	select CPU_FREQ_GOV_PERFORMANCE
	help
	  Use the CPUFreq governor 'wheatley' as default.

config CPU_FREQ_DEFAULT_GOV_ZZMOOVE
	bool "zzmoove"
	select CPU_FREQ_GOV_ZZMOOVE
	select CPU_FREQ_GOV_PERFORMANCE
	---help---
	  Use the CPUFreq governor 'zzmoove' as default, using predefined
	  frequency lookup tables and optimized scaling triggers instead of
	  % frequency steps to get smooth up/downscaling dependant on CPU load.

config CPU_FREQ_DEFAULT_GOV_BADASS
	bool "badass"
	select CPU_FREQ_GOV_BADASS
	select CPU_FREQ_GOV_PERFORMANCE
	help
	  Use the CPUFreq governor 'badass' as default. This allows
	  you to get a full dynamic frequency capable system by simply
	  loading your cpufreq low-level hardware driver.
	  Be aware that not all cpufreq drivers support the badass
	  governor. If unsure have a look at the help section of the
	  driver. Fallback governor will be the performance governor.

config CPU_FREQ_DEFAULT_GOV_IMPULSE
	bool "impulse"
	select CPU_FREQ_GOV_IMPULSE
	help
	  Use the CPUFreq governor 'impulse' as default. This allows
	  you to get a full dynamic cpu frequency capable system by simply
	  loading your cpufreq low-level hardware driver, using the
	  'impulse' governor for latency-sensitive workloads.

endchoice

config CPU_FREQ_GOV_PERFORMANCE
	tristate "'performance' governor"
	help
	  This cpufreq governor sets the frequency statically to the
	  highest available CPU frequency.

	  To compile this driver as a module, choose M here: the
	  module will be called cpufreq_performance.

	  If in doubt, say Y.

config CPU_FREQ_GOV_POWERSAVE
	tristate "'powersave' governor"
	help
	  This cpufreq governor sets the frequency statically to the
	  lowest available CPU frequency.

	  To compile this driver as a module, choose M here: the
	  module will be called cpufreq_powersave.

	  If in doubt, say Y.

config CPU_FREQ_GOV_USERSPACE
	tristate "'userspace' governor for userspace frequency scaling"
	help
	  Enable this cpufreq governor when you either want to set the
	  CPU frequency manually or when a userspace program shall
	  be able to set the CPU dynamically, like on LART 
	  <http://www.lartmaker.nl/>.

	  To compile this driver as a module, choose M here: the
	  module will be called cpufreq_userspace.

	  For details, take a look at <file:Documentation/cpu-freq/>.

	  If in doubt, say Y.

config CPU_FREQ_GOV_ONDEMAND
	tristate "'ondemand' cpufreq policy governor"
	select CPU_FREQ_TABLE
	select CPU_FREQ_GOV_COMMON
	help
	  'ondemand' - This driver adds a dynamic cpufreq policy governor.
	  The governor does a periodic polling and 
	  changes frequency based on the CPU utilization.
	  The support for this governor depends on CPU capability to
	  do fast frequency switching (i.e, very low latency frequency
	  transitions). 

	  To compile this driver as a module, choose M here: the
	  module will be called cpufreq_ondemand.

	  For details, take a look at linux/Documentation/cpu-freq.

	  If in doubt, say N.

config CPU_FREQ_GOV_INTERACTIVE
	tristate "'interactive' cpufreq policy governor"
	help
	  'interactive' - This driver adds a dynamic cpufreq policy governor
	  designed for latency-sensitive workloads.

	  This governor attempts to reduce the latency of clock
	  increases so that the system is more responsive to
	  interactive workloads.

	  To compile this driver as a module, choose M here: the
	  module will be called cpufreq_interactive.

	  For details, take a look at linux/Documentation/cpu-freq.

	  If in doubt, say N.

config CPU_FREQ_GOV_CONSERVATIVE
	tristate "'conservative' cpufreq governor"
	depends on CPU_FREQ
	select CPU_FREQ_GOV_COMMON
	help
	  'conservative' - this driver is rather similar to the 'ondemand'
	  governor both in its source code and its purpose, the difference is
	  its optimisation for better suitability in a battery powered
	  environment.  The frequency is gracefully increased and decreased
	  rather than jumping to 100% when speed is required.

	  If you have a desktop machine then you should really be considering
	  the 'ondemand' governor instead, however if you are using a laptop,
	  PDA or even an AMD64 based computer (due to the unacceptable
	  step-by-step latency issues between the minimum and maximum frequency
	  transitions in the CPU) you will probably want to use this governor.

	  To compile this driver as a module, choose M here: the
	  module will be called cpufreq_conservative.

	  For details, take a look at linux/Documentation/cpu-freq.

	  If in doubt, say N.

config CPU_FREQ_GOV_SPRDEMAND
	tristate "'sprdemand' cpufreq policy governor"
	select CPU_FREQ_TABLE
	select CPU_FREQ_GOV_COMMON
	help
	  'sprdemand' - this driver mimics the frequency scaling behavior
	  in 'ondemand', but with some key differences. 'sprdemand' will
	  offline auxillary CPUs when the system is idle, and online those
	  CPUs once the system becomes busy again. This last feature is needed for
	  architectures which transition to low power states when only
	  the "master" CPU is online, or for thermally constrained
	  devices.

	  If you don't have one of these architectures or devices, use
	  'ondemand' instead.

config CPU_FREQ_GOV_MINMAX
	tristate "'minmax' cpufreq governor"
	depends on CPU_FREQ
	help
	  'minmax' - this driver tries to minimize the frequency jumps by limiting
	  the the selected frequencies to either the min or the max frequency of
	  the policy. The frequency is selected according to the load.

	  If in doubt, say N.

config CPU_FREQ_GOV_DARKNESS
	tristate "'darkness' cpufreq governor"
	depends on CPU_FREQ

config CPU_FREQ_GOV_LIONHEART
	tristate "'lionheart' cpufreq governor"
depends on CPU_FREQ

config CPU_FREQ_GOV_HOTPLUG
	tristate "'hotplug' cpufreq governor"
depends on CPU_FREQ

config CPU_FREQ_GOV_HYPER
        tristate "'HYPER' cpufreq policy governor"
        depends on CPU_FREQ

config CPU_FREQ_GOV_ONDEMANDPLUS
	tristate "'ondemandplus' cpufreq policy governor"
	select CPU_FREQ_TABLE
	help
	  'ondemandplus' - This driver adds a dynamic cpufreq policy 
	  governor. The governor does a periodic polling and 
	  changes frequency based on the CPU utilization.
	  The support for this governor depends on CPU capability to
	  do fast frequency switching (i.e, very low latency frequency
	  transitions). 

	  To compile this driver as a module, choose M here: the
	  module will be called cpufreq_ondemandplus.

	  For details, take a look at linux/Documentation/cpu-freq.

	  If in doubt, say N.

config CPU_FREQ_GOV_ONDEMANDX
	tristate "'ondemandx' cpufreq policy governor"
	select CPU_FREQ_TABLE
	help
	  'ondemand' - This driver adds a dynamic cpufreq policy governor.
	  The governor does a periodic polling and 
	  changes frequency based on the CPU utilization.
	  The support for this governor depends on CPU capability to
	  do fast frequency switching (i.e, very low latency frequency
	  transitions). 

	  To compile this driver as a module, choose M here: the
	  module will be called cpufreq_ondemand.

	  For details, take a look at linux/Documentation/cpu-freq.

	  If in doubt, say N.

config CPU_FREQ_GOV_ONDEMANDX_INPUT
	bool "Ramp up CPU frequency on input events"
	default y
	depends on CPU_FREQ_GOV_ONDEMANDX
	help
	  Enable installation of an input event handler which will ramp up the
	  CPU to max frequency when an input event is received.

config CPU_FREQ_GOV_INTELLIACTIVE
	tristate "intelliactive"
	help
	  Use the CPUFreq governor 'intelliactive' as default. This allows
	  you to get a full dynamic cpu frequency capable system by simply
	  loading your cpufreq low-level hardware driver, using the
	  'interactive' governor for latency-sensitive workloads.

config CPU_FREQ_GOV_LAGFREE
	tristate "'lagfree' cpufreq governor"
	depends on CPU_FREQ
	help
	  'lagfree' - this driver is rather similar to the 'ondemand'
	  governor both in its source code and its purpose, the difference is
	  its optimisation for better suitability in a battery powered
	  environment.  The frequency is gracefully increased and decreased
	  rather than jumping to 100% when speed is required.

	  To compile this driver as a module, choose M here: the
	  module will be called cpufreq_lagfree.

	  If in doubt, say N.

config LAGFREE_MAX_LOAD
	int "Max CPU Load"
	default 50
	depends on CPU_FREQ_GOV_LAGFREE
	help
	  CPU freq will be increased if measured load > max_cpu_load;

config LAGFREE_MIN_LOAD
	int "Min CPU Load"
	default 15
	depends on CPU_FREQ_GOV_LAGFREE
	help
	  CPU freq will be decrease if measured load < min_cpu_load;

config LAGFREE_FREQ_STEP_DOWN
	int "Frequency Step Down"
	default 108000
	depends on CPU_FREQ_GOV_LAGFREE
	help
	  Max freqeuncy delta when ramping down.

config LAGFREE_FREQ_SLEEP_MAX
	int "Max Sleep frequeny"
	default 384000
	depends on CPU_FREQ_GOV_LAGFREE
	help
	  Max freqeuncy for screen off.

config LAGFREE_FREQ_AWAKE_MIN
	int "Min Awake frequeny"
	default 384000
	depends on CPU_FREQ_GOV_LAGFREE
	help
	  Min freqeuncy for screen on.

config LAGFREE_FREQ_STEP_UP_SLEEP_PERCENT
	int "Freq step up percent sleep"
	default 20
	depends on CPU_FREQ_GOV_LAGFREE
	help
	  Frequency percent to step up while screen off.

config CPU_FREQ_MIN_TICKS
	int "Ticks between governor polling interval."
	depends on CPU_FREQ_GOV_LAGFREE
	default 10
	help
	  Minimum number of ticks between polling interval for governors.

config CPU_FREQ_SAMPLING_LATENCY_MULTIPLIER
	int "Sampling rate multiplier for governors."
	depends on CPU_FREQ_GOV_LAGFREE
	default 1000
	help
	  Sampling latency rate multiplied by the cpu switch latency.

	  Affects governor polling.

config CPU_FREQ_GOV_NIGHTMARE
	tristate "'nightmare' cpufreq governor"
	depends on CPU_FREQ

config CPU_FREQ_GOV_SCARY
	tristate "'scary' cpufreq governor"
	depends on CPU_FREQ
	---help---
	  scary - a governor for cabbages

	  If in doubt, say N.

config CPU_FREQ_GOV_SLEEPY
	tristate "'sleepy' cpufreq governor"
	depends on CPU_FREQ
	---help---
          'sleepy' - an "ondemandx" based tweaked, smart and smooth optimized governor!

config CPU_FREQ_GOV_WHEATLEY
	tristate "'wheatley' cpufreq governor"
	depends on CPU_FREQ

config CPU_FREQ_GOV_ZZMOOVE
	tristate "'zzmoove' cpufreq governor"
	depends on CPU_FREQ
	---help---
    'zzmoove' - based on cpufreq_conservative, using predefined
	  frequency lookup tables and optimized scaling triggers instead of
	  % frequency steps to get smooth up/downscaling dependant on CPU load.

	  If in doubt, say N.

config CPU_FREQ_GOV_BADASS
	tristate "'badass' cpufreq policy governor"
	select CPU_FREQ_TABLE
	help
		'badass' - This driver adds a dynamic cpufreq policy governor.
		The governor does a periodic polling and
		changes frequency based on the CPU utilization.
		The support for this governor depends on CPU capability to
		do fast frequency switching (i.e, very low latency frequency
		transitions).
		To compile this driver as a module, choose M here: the
		module will be called cpufreq_badass.

config CPU_FREQ_GOV_BADASS_2_PHASE
	tristate "'2-phase' power-efficiency badass algorithm"
	depends on CPU_FREQ_GOV_BADASS
	help
		'2-phase' - This driver adds a new algo to save power

config CPU_FREQ_GOV_BADASS_2_PHASE_FREQ
	int "'2-phase' badass frequency"
	default 972000
	depends on CPU_FREQ_GOV_BADASS
	depends on CPU_FREQ_GOV_BADASS_2_PHASE

config CPU_FREQ_GOV_BADASS_3_PHASE
	tristate "'3-phase' power-efficiency badass algorithm"
	depends on CPU_FREQ_GOV_BADASS
	depends on CPU_FREQ_GOV_BADASS_2_PHASE
	help
		'3-phase' - This driver adds a new algo to save power

config CPU_FREQ_GOV_BADASS_3_PHASE_FREQ
	int "'3-phase' badass frequency"
	default 1296000
	depends on CPU_FREQ_GOV_BADASS
	depends on CPU_FREQ_GOV_BADASS_2_PHASE
	depends on CPU_FREQ_GOV_BADASS_3_PHASE

config CPU_FREQ_GOV_BADASS_GPU_CONTROL
	tristate "'gpu_control' power-efficiency badass algorithm"
	depends on CPU_FREQ_GOV_BADASS
	depends on CPU_FREQ_GOV_BADASS_2_PHASE
	help
		'gpu_control' - This driver adds a new algo to save power

config CPU_FREQ_GOV_BADASS_LOWBAT_POWERSAVE
	tristate "'lowbat_powersave' power-efficiency badass algorithm"
	depends on CPU_FREQ_GOV_BADASS
	help
		'lowbat_powersave' - This driver adds a new algo to save power

config CPU_FREQ_GOV_BADASS_ALLOW_BYPASS
	tristate "Allows bypassing phases"
	depends on CPU_FREQ_GOV_BADASS
	depends on CPU_FREQ_GOV_BADASS_2_PHASE
	help
		'allow_bypass' - This driver adds a bypass to the phases

config CPU_FREQ_GOV_IMPULSE
	tristate "'impulse' cpufreq policy governor"
	help
	  'impulse' - This driver adds a dynamic cpufreq policy governor
	  designed for latency-sensitive workloads.

	  If in doubt, say N.

config SCX35_1300MHZ
	bool "SCX35 1300MHZ"
	depends on ARCH_SCX35
	default n
	help
	  enable the 1300MHZ

config GENERIC_CPUFREQ_CPU0
	tristate "Generic CPU0 cpufreq driver"
	depends on HAVE_CLK && REGULATOR && PM_OPP && OF
	select CPU_FREQ_TABLE
	help
	  This adds a generic cpufreq driver for CPU0 frequency management.
	  It supports both uniprocessor (UP) and symmetric multiprocessor (SMP)
	  systems which share clock and voltage across all CPUs.

	  If in doubt, say N.

menu "x86 CPU frequency scaling drivers"
depends on X86
source "drivers/cpufreq/Kconfig.x86"
endmenu

menu "ARM CPU frequency scaling drivers"
depends on ARM
source "drivers/cpufreq/Kconfig.arm"
endmenu

menu "AVR32 CPU frequency scaling drivers"
depends on AVR32

config AVR32_AT32AP_CPUFREQ
	bool "CPU frequency driver for AT32AP"
	depends on PLATFORM_AT32AP
	default n
	help
	  This enables the CPU frequency driver for AT32AP processors.
	  If in doubt, say N.

endmenu

menu "CPUFreq processor drivers"
depends on IA64

config IA64_ACPI_CPUFREQ
	tristate "ACPI Processor P-States driver"
	select CPU_FREQ_TABLE
	depends on ACPI_PROCESSOR
	help
	This driver adds a CPUFreq driver which utilizes the ACPI
	Processor Performance States.

	For details, take a look at <file:Documentation/cpu-freq/>.

	If in doubt, say N.

endmenu

menu "MIPS CPUFreq processor drivers"
depends on MIPS

config LOONGSON2_CPUFREQ
	tristate "Loongson2 CPUFreq Driver"
	select CPU_FREQ_TABLE
	help
	  This option adds a CPUFreq driver for loongson processors which
	  support software configurable cpu frequency.

	  Loongson2F and it's successors support this feature.

	  For details, take a look at <file:Documentation/cpu-freq/>.

	  If in doubt, say N.

endmenu

menu "PowerPC CPU frequency scaling drivers"
depends on PPC32 || PPC64
source "drivers/cpufreq/Kconfig.powerpc"
endmenu

menu "SPARC CPU frequency scaling drivers"
depends on SPARC64
config SPARC_US3_CPUFREQ
	tristate "UltraSPARC-III CPU Frequency driver"
	select CPU_FREQ_TABLE
	help
	  This adds the CPUFreq driver for UltraSPARC-III processors.

	  For details, take a look at <file:Documentation/cpu-freq>.

	  If in doubt, say N.

config SPARC_US2E_CPUFREQ
	tristate "UltraSPARC-IIe CPU Frequency driver"
	select CPU_FREQ_TABLE
	help
	  This adds the CPUFreq driver for UltraSPARC-IIe processors.

	  For details, take a look at <file:Documentation/cpu-freq>.

	  If in doubt, say N.
endmenu

menu "SH CPU Frequency scaling"
depends on SUPERH
config SH_CPU_FREQ
	tristate "SuperH CPU Frequency driver"
	select CPU_FREQ_TABLE
	help
	  This adds the cpufreq driver for SuperH. Any CPU that supports
	  clock rate rounding through the clock framework can use this
	  driver. While it will make the kernel slightly larger, this is
	  harmless for CPUs that don't support rate rounding. The driver
	  will also generate a notice in the boot log before disabling
	  itself if the CPU in question is not capable of rate rounding.

	  For details, take a look at <file:Documentation/cpu-freq>.

	  If unsure, say N.
endmenu

endif
endmenu

config CPU_FREQ_GOV_HOTPLUG
	tristate "'hotplug' cpufreq governor"
	depends on CPU_FREQ && NO_HZ && HOTPLUG_CPU
	help
	  'hotplug' - this driver mimics the frequency scaling behavior
	  in 'ondemand', but with several key differences.  First is
	  that frequency transitions use the CPUFreq table directly,
	  instead of incrementing in a percentage of the maximum
	  available frequency.  Second 'hotplug' will offline auxillary
	  CPUs when the system is idle, and online those CPUs once the
	  system becomes busy again.  This last feature is needed for
	  architectures which transition to low power states when only
	  the "master" CPU is online, or for thermally constrained
	  devices.

	  If you don't have one of these architectures or devices, use
	  'ondemand' instead.

	  If in doubt, say N.

config CPU_FREQ_GOV_INTELLIACTIVE
	tristate "'intelliactive' cpufreq policy governor"
	help
	  'intelliactive' - This driver adds a dynamic cpufreq policy governor
	  designed for latency-sensitive workloads.

	  This governor attempts to reduce the latency of clock
	  increases so that the system is more responsive to
	  interactive workloads.

	  To compile this driver as a module, choose M here: the
	  module will be called cpufreq_interactive.

	  For details, take a look at linux/Documentation/cpu-freq.

	  If in doubt, say N.
